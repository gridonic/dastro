---
---

<div class="debug-css-variables">
  <div class="title">CSS Variables</div>
  <div class="variable-control" data-css-var-container="--fluid-size-max" data-responsive="true">
    <label class="label" for="css-var-fluid-size-max">
      <span class="label-text">--fluid-size-max <span class="responsive-badge" title="This value changes based on viewport size">responsive</span></span>
      <span class="value-wrapper">
        <button
          type="button"
          class="reset-icon"
          data-css-var="--fluid-size-max"
          aria-label="Reset to original value"
          title="Reset to original value"
        >
          <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
            <path
              d="M13.65 2.35C12.2 0.9 10.2 0 8 0C3.58 0 0 3.58 0 8C0 12.42 3.58 16 8 16C11.73 16 14.84 13.45 15.73 10H13.65C12.83 12.33 10.61 14 8 14C4.69 14 2 11.31 2 8C2 4.69 4.69 2 8 2C9.66 2 11.14 2.69 12.22 3.78L9 7H16V0L13.65 2.35Z"
              fill="currentColor"
            />
          </svg>
        </button>
        <span class="value" data-css-var-value="--fluid-size-max"></span>
      </span>
    </label>
    <div class="input-group">
      <input
        type="range"
        id="css-var-fluid-size-max"
        class="slider"
        data-css-var="--fluid-size-max"
        min="0"
        max="200"
        step="1"
      />
      <input
        type="number"
        class="number-input"
        data-css-var="--fluid-size-max"
        min="0"
        max="200"
        step="1"
      />
    </div>
  </div>
  <div class="variable-control" data-css-var-container="--fluid-size-min" data-responsive="true">
    <label class="label" for="css-var-fluid-size-min">
      <span class="label-text">--fluid-size-min <span class="responsive-badge" title="This value changes based on viewport size">responsive</span></span>
      <span class="value-wrapper">
        <button
          type="button"
          class="reset-icon"
          data-css-var="--fluid-size-min"
          aria-label="Reset to original value"
          title="Reset to original value"
        >
          <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
            <path
              d="M13.65 2.35C12.2 0.9 10.2 0 8 0C3.58 0 0 3.58 0 8C0 12.42 3.58 16 8 16C11.73 16 14.84 13.45 15.73 10H13.65C12.83 12.33 10.61 14 8 14C4.69 14 2 11.31 2 8C2 4.69 4.69 2 8 2C9.66 2 11.14 2.69 12.22 3.78L9 7H16V0L13.65 2.35Z"
              fill="currentColor"
            />
          </svg>
        </button>
        <span class="value" data-css-var-value="--fluid-size-min"></span>
      </span>
    </label>
    <div class="input-group">
      <input
        type="range"
        id="css-var-fluid-size-min"
        class="slider"
        data-css-var="--fluid-size-min"
        min="0"
        max="200"
        step="1"
      />
      <input
        type="number"
        class="number-input"
        data-css-var="--fluid-size-min"
        min="0"
        max="200"
        step="1"
      />
    </div>
  </div>
  <div class="variable-control" data-css-var-container="--fluid-max-width-base">
    <label class="label" for="css-var-fluid-max-width-base">
      <span class="label-text">--fluid-max-width-base</span>
      <span class="value-wrapper">
        <button
          type="button"
          class="reset-icon"
          data-css-var="--fluid-max-width-base"
          aria-label="Reset to original value"
          title="Reset to original value"
        >
          <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
            <path
              d="M13.65 2.35C12.2 0.9 10.2 0 8 0C3.58 0 0 3.58 0 8C0 12.42 3.58 16 8 16C11.73 16 14.84 13.45 15.73 10H13.65C12.83 12.33 10.61 14 8 14C4.69 14 2 11.31 2 8C2 4.69 4.69 2 8 2C9.66 2 11.14 2.69 12.22 3.78L9 7H16V0L13.65 2.35Z"
              fill="currentColor"
            />
          </svg>
        </button>
        <span class="value" data-css-var-value="--fluid-max-width-base"></span>
      </span>
    </label>
    <div class="input-group">
      <input
        type="range"
        id="css-var-fluid-max-width-base"
        class="slider"
        data-css-var="--fluid-max-width-base"
        min="800"
        max="3200"
        step="1"
      />
      <input
        type="number"
        class="number-input"
        data-css-var="--fluid-max-width-base"
        min="800"
        max="3200"
        step="1"
      />
    </div>
  </div>
  <div class="variable-control" data-css-var-container="--fluid-rate-of-reduction">
    <label class="label" for="css-var-fluid-rate-of-reduction">
      <span class="label-text">--fluid-rate-of-reduction</span>
      <span class="value-wrapper">
        <button
          type="button"
          class="reset-icon"
          data-css-var="--fluid-rate-of-reduction"
          aria-label="Reset to original value"
          title="Reset to original value"
        >
          <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
            <path
              d="M13.65 2.35C12.2 0.9 10.2 0 8 0C3.58 0 0 3.58 0 8C0 12.42 3.58 16 8 16C11.73 16 14.84 13.45 15.73 10H13.65C12.83 12.33 10.61 14 8 14C4.69 14 2 11.31 2 8C2 4.69 4.69 2 8 2C9.66 2 11.14 2.69 12.22 3.78L9 7H16V0L13.65 2.35Z"
              fill="currentColor"
            />
          </svg>
        </button>
        <span class="value" data-css-var-value="--fluid-rate-of-reduction"></span>
      </span>
    </label>
    <div class="input-group">
      <input
        type="range"
        id="css-var-fluid-rate-of-reduction"
        class="slider"
        data-css-var="--fluid-rate-of-reduction"
        min="30"
        max="70"
        step="1"
      />
      <input
        type="number"
        class="number-input"
        data-css-var="--fluid-rate-of-reduction"
        min="30"
        max="70"
        step="1"
      />
    </div>
  </div>
</div>

<script>
  import { registerComponent, BaseComponent } from '../../client';

  registerComponent(
    '.debug-css-variables',
    class DebugCssVariables extends BaseComponent {
      private readonly storageKey = 'debug-css-variables';
      private variableControls: Map<string, { slider: HTMLInputElement; numberInput: HTMLInputElement; valueDisplay: HTMLElement; resetIcon: HTMLButtonElement }> = new Map();
      private originalValues: Map<string, string> = new Map();
      private readonly responsiveVariables = ['--fluid-size-min', '--fluid-size-max'];
      private resizeTimeout: number | null = null;

      init() {
        // Store original values first, before any modifications
        this.storeOriginalValues();
        // Set up controls
        this.setupVariableControls();
        // Load saved values after controls are set up
        // This will override initial CSS values if saved values exist
        this.loadSavedValues();
        // Update display to show current values
        this.updateDisplayValues();
        // Set up resize listener for responsive variables
        this.setupResizeListener();
      }

      private storeOriginalValues() {
        const controls = this.$el.querySelectorAll('[data-css-var]');
        controls.forEach((control) => {
          const variableName = control.getAttribute('data-css-var');
          if (!variableName) return;
          
          // Get the original value from CSS before any modifications
          const originalValue = getComputedStyle(document.documentElement)
            .getPropertyValue(variableName)
            .trim();
          this.originalValues.set(variableName, originalValue || '0');
        });
      }

      private setupVariableControls() {
        const controls = this.$el.querySelectorAll('[data-css-var]');
        
        controls.forEach((control) => {
          const variableName = control.getAttribute('data-css-var');
          if (!variableName) return;

          if (!this.variableControls.has(variableName)) {
            const slider = this.$el.querySelector(
              `input[type="range"][data-css-var="${variableName}"]`
            ) as HTMLInputElement;
            const numberInput = this.$el.querySelector(
              `input[type="number"][data-css-var="${variableName}"]`
            ) as HTMLInputElement;
            const valueDisplay = this.$el.querySelector(
              `[data-css-var-value="${variableName}"]`
            ) as HTMLElement;
            const resetIcon = this.$el.querySelector(
              `button.reset-icon[data-css-var="${variableName}"]`
            ) as HTMLButtonElement;

            if (slider && numberInput && valueDisplay && resetIcon) {
              // Get original value (already stored in storeOriginalValues)
              const originalValue = this.originalValues.get(variableName) || '0';

              this.variableControls.set(variableName, {
                slider,
                numberInput,
                valueDisplay,
                resetIcon,
              });

              // Get initial value from CSS (will be overridden by saved values if they exist)
              const initialValue = originalValue;
              const numericValue = this.parseValue(initialValue);
              
              if (numericValue !== null) {
                slider.value = numericValue.toString();
                numberInput.value = numericValue.toString();
              } else {
                // Default to 0 if value can't be parsed
                slider.value = '0';
                numberInput.value = '0';
              }

              // Bind events
              slider.addEventListener('input', () => {
                this.updateVariable(variableName, slider.value);
              });

              numberInput.addEventListener('input', () => {
                this.updateVariable(variableName, numberInput.value);
              });

              // Sync slider and number input
              slider.addEventListener('input', () => {
                numberInput.value = slider.value;
              });

              numberInput.addEventListener('input', () => {
                const numValue = parseFloat(numberInput.value);
                if (!isNaN(numValue)) {
                  slider.value = numValue.toString();
                }
              });

              // Bind reset icon
              resetIcon.addEventListener('click', () => {
                this.resetVariable(variableName);
              });
            }
          }
        });
      }

      private getCurrentValue(variableName: string): string {
        const value = getComputedStyle(document.documentElement)
          .getPropertyValue(variableName)
          .trim();
        return value || '0';
      }

      private parseValue(value: string): number | null {
        // Extract numeric value from CSS value (e.g., "100px" -> 100, "1.5rem" -> 1.5)
        const match = value.match(/^([\d.]+)/);
        return match ? parseFloat(match[1]) : null;
      }

      private updateVariable(variableName: string, value: string, save: boolean = true) {
        const numValue = parseFloat(value);
        if (isNaN(numValue)) return;

        // Determine unit from original value, default to px
        const originalValue = this.getCurrentValue(variableName);
        const unitMatch = originalValue.match(/[\d.]+(.*)/);
        const unit = unitMatch && unitMatch[1] ? unitMatch[1] : 'px';

        const newValue = `${numValue}${unit}`;
        document.documentElement.style.setProperty(variableName, newValue);
        
        this.updateDisplayValue(variableName);
        this.updateModifiedState(variableName);
        if (save) {
          this.saveValue(variableName, numValue);
        }
      }

      private updateDisplayValue(variableName: string) {
        const control = this.variableControls.get(variableName);
        if (!control) return;

        const currentValue = this.getCurrentValue(variableName);
        control.valueDisplay.textContent = currentValue;
      }

      private updateDisplayValues() {
        this.variableControls.forEach((_, variableName) => {
          this.updateDisplayValue(variableName);
          this.updateModifiedState(variableName);
        });
      }

      private setupResizeListener() {
        // Use a debounced resize listener to update responsive variables
        window.addEventListener('resize', () => {
          if (this.resizeTimeout) {
            clearTimeout(this.resizeTimeout);
          }
          
          this.resizeTimeout = window.setTimeout(() => {
            // Update only responsive variables when viewport changes
            this.responsiveVariables.forEach((variableName) => {
              if (this.variableControls.has(variableName)) {
                // Only update if value hasn't been manually overridden
                const control = this.variableControls.get(variableName);
                if (!control) return;
                
                // Check if there's a saved override value
                try {
                  const saved = JSON.parse(
                    sessionStorage.getItem(this.storageKey) || '{}'
                  );
                  
                  // If no saved override, update the display and controls to show current responsive value
                  if (typeof saved[variableName] !== 'number') {
                    const currentValue = this.getCurrentValue(variableName);
                    const numericValue = this.parseValue(currentValue);
                    
                    if (numericValue !== null) {
                      // Update slider and number input to reflect current responsive value
                      control.slider.value = numericValue.toString();
                      control.numberInput.value = numericValue.toString();
                    }
                    
                    this.updateDisplayValue(variableName);
                    this.updateModifiedState(variableName);
                  }
                } catch (error) {
                  // If error reading storage, just update display
                  const currentValue = this.getCurrentValue(variableName);
                  const numericValue = this.parseValue(currentValue);
                  
                  if (numericValue !== null) {
                    control.slider.value = numericValue.toString();
                    control.numberInput.value = numericValue.toString();
                  }
                  
                  this.updateDisplayValue(variableName);
                  this.updateModifiedState(variableName);
                }
              }
            });
          }, 150);
        });
      }

      private updateModifiedState(variableName: string) {
        const container = this.$el.querySelector(
          `[data-css-var-container="${variableName}"]`
        ) as HTMLElement;
        if (!container) return;

        const control = this.variableControls.get(variableName);
        if (!control) return;

        const isResponsive = this.responsiveVariables.includes(variableName);
        let isModified = false;

        if (isResponsive) {
          // For responsive variables, check if there's a manual override in sessionStorage
          // or an inline style override
          try {
            const saved = JSON.parse(
              sessionStorage.getItem(this.storageKey) || '{}'
            );
            isModified = typeof saved[variableName] === 'number';
          } catch (error) {
            isModified = false;
          }
          
          // Also check if there's an inline style override
          const inlineStyle = document.documentElement.style.getPropertyValue(variableName);
          if (inlineStyle && inlineStyle.trim() !== '') {
            isModified = true;
          }
        } else {
          // For non-responsive variables, compare current value with original
          const originalValue = this.originalValues.get(variableName) || '0';
          const currentValue = this.getCurrentValue(variableName);
          
          // Normalize values for comparison (remove whitespace, handle empty strings)
          const normalizedOriginal = originalValue.trim() || '0';
          const normalizedCurrent = currentValue.trim() || '0';
          
          // Check if values differ
          isModified = normalizedOriginal !== normalizedCurrent;
        }
        
        container.classList.toggle('-modified', isModified);
        // Show/hide reset icon based on modified state (using visibility to prevent layout shift)
        control.resetIcon.style.visibility = isModified ? 'visible' : 'hidden';
        control.resetIcon.style.pointerEvents = isModified ? 'auto' : 'none';
      }

      private saveValue(variableName: string, value: number) {
        try {
          const saved = JSON.parse(
            sessionStorage.getItem(this.storageKey) || '{}'
          );
          saved[variableName] = value;
          sessionStorage.setItem(this.storageKey, JSON.stringify(saved));
        } catch (error) {
          console.warn('Unable to save CSS variable value', error);
        }
      }

      private loadSavedValues() {
        try {
          const saved = JSON.parse(
            sessionStorage.getItem(this.storageKey) || '{}'
          );

          this.variableControls.forEach((control, variableName) => {
            const savedValue = saved[variableName];
            if (typeof savedValue === 'number') {
              control.slider.value = savedValue.toString();
              control.numberInput.value = savedValue.toString();
              // Apply the saved value to the CSS variable
              this.updateVariable(variableName, savedValue.toString(), false);
            } else {
              // Even if no saved value, check modified state in case CSS was changed externally
              this.updateModifiedState(variableName);
            }
          });
        } catch (error) {
          console.warn('Unable to load saved CSS variable values', error);
        }
      }

      private resetVariable(variableName: string) {
        const control = this.variableControls.get(variableName);
        if (!control) return;

        // Remove from sessionStorage first
        try {
          const saved = JSON.parse(
            sessionStorage.getItem(this.storageKey) || '{}'
          );
          delete saved[variableName];
          sessionStorage.setItem(this.storageKey, JSON.stringify(saved));
        } catch (error) {
          console.warn('Unable to remove CSS variable value from storage', error);
        }

        // Remove the inline style to restore original CSS value
        document.documentElement.style.removeProperty(variableName);

        // For responsive variables, get current value (which may vary by viewport)
        // For non-responsive, use stored original value
        const isResponsive = this.responsiveVariables.includes(variableName);
        const valueToUse = isResponsive 
          ? this.getCurrentValue(variableName)
          : (this.originalValues.get(variableName) || '0');

        // Update controls to show current value
        const numericValue = this.parseValue(valueToUse);
        if (numericValue !== null) {
          control.slider.value = numericValue.toString();
          control.numberInput.value = numericValue.toString();
        }

        // Update display and modified state
        // Use a small delay to ensure DOM has updated
        setTimeout(() => {
          this.updateDisplayValue(variableName);
          this.updateModifiedState(variableName);
        }, 0);
      }
    },
  );
</script>

<style lang="scss">
  .debug-css-variables {
    display: flex;
    flex-direction: column;
    gap: 6px;
    padding: 13px 16px 16px;
    border-top: 1px solid var(--debug-view-color-lines, #e3e1e1);

    > .title {
      font-weight: bold;
      margin-bottom: 2px;
      text-transform: uppercase;
      letter-spacing: 0.64px;
      font-size: 10px;
      color: rgba(0, 0, 0, 0.6);
    }

    > .variable-control {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 8px;
      border-radius: 4px;
      transition: background-color 0.2s ease;

      &.-modified {
        background-color: rgba(255, 200, 200, 0.3);
      }

      > .label {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 11px;
        color: var(--debug-view-foreground-color, black);
        gap: 8px;

        > .label-text {
          font-weight: 600;
          font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;

          > .responsive-badge {
            display: inline-block;
            margin-left: 6px;
            padding: 2px 6px;
            font-size: 8px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: rgba(0, 0, 0, 0.5);
            background: rgba(0, 0, 0, 0.05);
            border-radius: 3px;
            vertical-align: middle;
          }
        }

        > .value-wrapper {
          display: flex;
          align-items: center;
          gap: 6px;

          > .reset-icon {
            visibility: hidden;
            pointer-events: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            padding: 0;
            border: none;
            background: transparent;
            color: rgba(0, 0, 0, 0.5);
            cursor: pointer;
            transition:
              visibility 0.15s ease,
              color 0.15s ease,
              transform 0.15s ease;
            flex-shrink: 0;

            > svg {
              width: 100%;
              height: 100%;
            }

            &:hover {
              color: var(--debug-view-accent-color, rgba(40, 30, 213, 1));
              transform: rotate(180deg);
            }

            &:active {
              transform: rotate(180deg) scale(0.9);
            }

            &:focus {
              outline: none;
              color: var(--debug-view-accent-color, rgba(40, 30, 213, 1));
            }
          }

          > .value {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: rgba(0, 0, 0, 0.7);
            font-weight: 500;
          }
        }
      }

      > .input-group {
        display: flex;
        align-items: center;
        gap: 8px;

        > .slider {
          flex: 1;
          height: 6px;
          border-radius: 3px;
          background: var(--debug-view-color-lines, #e3e1e1);
          outline: none;
          -webkit-appearance: none;
          appearance: none;

          &::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--debug-view-accent-color, rgba(40, 30, 213, 1));
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: transform 0.15s ease;

            &:hover {
              transform: scale(1.1);
            }
          }

          &::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--debug-view-accent-color, rgba(40, 30, 213, 1));
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: transform 0.15s ease;

            &:hover {
              transform: scale(1.1);
            }
          }
        }

        > .number-input {
          width: 60px;
          padding: 6px 8px;
          border: 1px solid var(--debug-view-color-lines, #e3e1e1);
          border-radius: 4px;
          font-size: 11px;
          font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
          background: white;
          color: var(--debug-view-foreground-color, black);
          transition:
            border-color 0.15s ease,
            box-shadow 0.15s ease;

          &:focus {
            outline: none;
            border-color: var(--debug-view-accent-color, rgba(40, 30, 213, 1));
            box-shadow: 0 0 0 2px rgba(40, 30, 213, 0.1);
          }
        }

      }
    }
  }
</style>
