---
---

<div class="debug-css-variables">
  <div class="viewport-group" data-viewport-group="small">
    <div class="viewport-group-header">
      <span class="viewport-group-title">Small Viewport</span>
      <span class="viewport-group-badge">--vs</span>
    </div>
    <div class="viewport-group-controls">
      <div class="variable-control" data-css-var-container="--fluid-size-max" data-viewport="small" data-media-query="--vs">
        <label class="label" for="css-var-fluid-size-max-small">
          <span class="label-text">--fluid-size-max</span>
          <span class="value-wrapper">
            <button
              type="button"
              class="reset-icon"
              data-css-var="--fluid-size-max"
              data-viewport="small"
              aria-label="Reset to original value"
              title="Reset to original value"
            >
              <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M13.65 2.35C12.2 0.9 10.2 0 8 0C3.58 0 0 3.58 0 8C0 12.42 3.58 16 8 16C11.73 16 14.84 13.45 15.73 10H13.65C12.83 12.33 10.61 14 8 14C4.69 14 2 11.31 2 8C2 4.69 4.69 2 8 2C9.66 2 11.14 2.69 12.22 3.78L9 7H16V0L13.65 2.35Z"
                  fill="currentColor"
                />
              </svg>
            </button>
            <span class="value" data-css-var-value="--fluid-size-max" data-viewport="small"></span>
          </span>
        </label>
        <div class="input-group">
          <input
            type="range"
            id="css-var-fluid-size-max-small"
            class="slider"
            data-css-var="--fluid-size-max"
            data-viewport="small"
            min="0"
            max="200"
            step="1"
          />
          <input
            type="number"
            class="number-input"
            data-css-var="--fluid-size-max"
            data-viewport="small"
            min="0"
            max="200"
            step="1"
          />
        </div>
      </div>
      <div class="variable-control" data-css-var-container="--fluid-size-min" data-viewport="small" data-media-query="--vs">
        <label class="label" for="css-var-fluid-size-min-small">
          <span class="label-text">--fluid-size-min</span>
          <span class="value-wrapper">
            <button
              type="button"
              class="reset-icon"
              data-css-var="--fluid-size-min"
              data-viewport="small"
              aria-label="Reset to original value"
              title="Reset to original value"
            >
              <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M13.65 2.35C12.2 0.9 10.2 0 8 0C3.58 0 0 3.58 0 8C0 12.42 3.58 16 8 16C11.73 16 14.84 13.45 15.73 10H13.65C12.83 12.33 10.61 14 8 14C4.69 14 2 11.31 2 8C2 4.69 4.69 2 8 2C9.66 2 11.14 2.69 12.22 3.78L9 7H16V0L13.65 2.35Z"
                  fill="currentColor"
                />
              </svg>
            </button>
            <span class="value" data-css-var-value="--fluid-size-min" data-viewport="small"></span>
          </span>
        </label>
        <div class="input-group">
          <input
            type="range"
            id="css-var-fluid-size-min-small"
            class="slider"
            data-css-var="--fluid-size-min"
            data-viewport="small"
            min="0"
            max="200"
            step="1"
          />
          <input
            type="number"
            class="number-input"
            data-css-var="--fluid-size-min"
            data-viewport="small"
            min="0"
            max="200"
            step="1"
          />
        </div>
      </div>
    </div>
  </div>
  <div class="viewport-group" data-viewport-group="large">
    <div class="viewport-group-header">
      <span class="viewport-group-title">Large Viewport</span>
      <span class="viewport-group-badge">--vl</span>
    </div>
    <div class="viewport-group-controls">
      <div class="variable-control" data-css-var-container="--fluid-size-max" data-viewport="large" data-media-query="--vl">
        <label class="label" for="css-var-fluid-size-max-large">
          <span class="label-text">--fluid-size-max</span>
          <span class="value-wrapper">
            <button
              type="button"
              class="reset-icon"
              data-css-var="--fluid-size-max"
              data-viewport="large"
              aria-label="Reset to original value"
              title="Reset to original value"
            >
              <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M13.65 2.35C12.2 0.9 10.2 0 8 0C3.58 0 0 3.58 0 8C0 12.42 3.58 16 8 16C11.73 16 14.84 13.45 15.73 10H13.65C12.83 12.33 10.61 14 8 14C4.69 14 2 11.31 2 8C2 4.69 4.69 2 8 2C9.66 2 11.14 2.69 12.22 3.78L9 7H16V0L13.65 2.35Z"
                  fill="currentColor"
                />
              </svg>
            </button>
            <span class="value" data-css-var-value="--fluid-size-max" data-viewport="large"></span>
          </span>
        </label>
        <div class="input-group">
          <input
            type="range"
            id="css-var-fluid-size-max-large"
            class="slider"
            data-css-var="--fluid-size-max"
            data-viewport="large"
            min="0"
            max="200"
            step="1"
          />
          <input
            type="number"
            class="number-input"
            data-css-var="--fluid-size-max"
            data-viewport="large"
            min="0"
            max="200"
            step="1"
          />
        </div>
      </div>
      <div class="variable-control" data-css-var-container="--fluid-size-min" data-viewport="large" data-media-query="--vl">
        <label class="label" for="css-var-fluid-size-min-large">
          <span class="label-text">--fluid-size-min</span>
          <span class="value-wrapper">
            <button
              type="button"
              class="reset-icon"
              data-css-var="--fluid-size-min"
              data-viewport="large"
              aria-label="Reset to original value"
              title="Reset to original value"
            >
              <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M13.65 2.35C12.2 0.9 10.2 0 8 0C3.58 0 0 3.58 0 8C0 12.42 3.58 16 8 16C11.73 16 14.84 13.45 15.73 10H13.65C12.83 12.33 10.61 14 8 14C4.69 14 2 11.31 2 8C2 4.69 4.69 2 8 2C9.66 2 11.14 2.69 12.22 3.78L9 7H16V0L13.65 2.35Z"
                  fill="currentColor"
                />
              </svg>
            </button>
            <span class="value" data-css-var-value="--fluid-size-min" data-viewport="large"></span>
          </span>
        </label>
        <div class="input-group">
          <input
            type="range"
            id="css-var-fluid-size-min-large"
            class="slider"
            data-css-var="--fluid-size-min"
            data-viewport="large"
            min="0"
            max="200"
            step="1"
          />
          <input
            type="number"
            class="number-input"
            data-css-var="--fluid-size-min"
            data-viewport="large"
            min="0"
            max="200"
            step="1"
          />
        </div>
      </div>
    </div>
  </div>
  <div class="variable-control" data-css-var-container="--fluid-max-width-base">
    <label class="label" for="css-var-fluid-max-width-base">
      <span class="label-text">--fluid-max-width-base</span>
      <span class="value-wrapper">
        <button
          type="button"
          class="reset-icon"
          data-css-var="--fluid-max-width-base"
          aria-label="Reset to original value"
          title="Reset to original value"
        >
          <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
            <path
              d="M13.65 2.35C12.2 0.9 10.2 0 8 0C3.58 0 0 3.58 0 8C0 12.42 3.58 16 8 16C11.73 16 14.84 13.45 15.73 10H13.65C12.83 12.33 10.61 14 8 14C4.69 14 2 11.31 2 8C2 4.69 4.69 2 8 2C9.66 2 11.14 2.69 12.22 3.78L9 7H16V0L13.65 2.35Z"
              fill="currentColor"
            />
          </svg>
        </button>
        <span class="value" data-css-var-value="--fluid-max-width-base"></span>
      </span>
    </label>
    <div class="input-group">
      <input
        type="range"
        id="css-var-fluid-max-width-base"
        class="slider"
        data-css-var="--fluid-max-width-base"
        min="800"
        max="3200"
        step="1"
      />
      <input
        type="number"
        class="number-input"
        data-css-var="--fluid-max-width-base"
        min="800"
        max="3200"
        step="1"
      />
    </div>
  </div>
  <div class="variable-control" data-css-var-container="--fluid-aspect-ratio-max">
    <label class="label" for="css-var-fluid-aspect-ratio-max">
      <span class="label-text">--fluid-aspect-ratio-max</span>
      <span class="value-wrapper">
        <button
          type="button"
          class="reset-icon"
          data-css-var="--fluid-aspect-ratio-max"
          aria-label="Reset to original value"
          title="Reset to original value"
        >
          <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
            <path
              d="M13.65 2.35C12.2 0.9 10.2 0 8 0C3.58 0 0 3.58 0 8C0 12.42 3.58 16 8 16C11.73 16 14.84 13.45 15.73 10H13.65C12.83 12.33 10.61 14 8 14C4.69 14 2 11.31 2 8C2 4.69 4.69 2 8 2C9.66 2 11.14 2.69 12.22 3.78L9 7H16V0L13.65 2.35Z"
              fill="currentColor"
            />
          </svg>
        </button>
        <span class="value" data-css-var-value="--fluid-aspect-ratio-max"></span>
      </span>
    </label>
    <div class="input-group">
      <input
        type="range"
        id="css-var-fluid-aspect-ratio-max"
        class="slider"
        data-css-var="--fluid-aspect-ratio-max"
        min="0.5"
        max="3"
        step="0.1"
      />
      <input
        type="number"
        class="number-input"
        data-css-var="--fluid-aspect-ratio-max"
        min="0.5"
        max="3"
        step="0.1"
      />
    </div>
  </div>
  <div class="variable-control" data-css-var-container="--fluid-rate-of-reduction">
    <label class="label" for="css-var-fluid-rate-of-reduction">
      <span class="label-text">--fluid-rate-of-reduction</span>
      <span class="value-wrapper">
        <button
          type="button"
          class="reset-icon"
          data-css-var="--fluid-rate-of-reduction"
          aria-label="Reset to original value"
          title="Reset to original value"
        >
          <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
            <path
              d="M13.65 2.35C12.2 0.9 10.2 0 8 0C3.58 0 0 3.58 0 8C0 12.42 3.58 16 8 16C11.73 16 14.84 13.45 15.73 10H13.65C12.83 12.33 10.61 14 8 14C4.69 14 2 11.31 2 8C2 4.69 4.69 2 8 2C9.66 2 11.14 2.69 12.22 3.78L9 7H16V0L13.65 2.35Z"
              fill="currentColor"
            />
          </svg>
        </button>
        <span class="value" data-css-var-value="--fluid-rate-of-reduction"></span>
      </span>
    </label>
    <div class="input-group">
      <input
        type="range"
        id="css-var-fluid-rate-of-reduction"
        class="slider"
        data-css-var="--fluid-rate-of-reduction"
        min="30"
        max="70"
        step="1"
      />
      <input
        type="number"
        class="number-input"
        data-css-var="--fluid-rate-of-reduction"
        min="30"
        max="70"
        step="1"
      />
    </div>
  </div>
</div>

<script>
  import { registerComponent, BaseComponent } from '../../client';

  registerComponent(
    '.debug-css-variables',
    class DebugCssVariables extends BaseComponent {
      private readonly storageKey = 'debug-css-variables';
      private variableControls: Map<string, { slider: HTMLInputElement; numberInput: HTMLInputElement; valueDisplay: HTMLElement; resetIcon: HTMLButtonElement; viewport?: 'small' | 'large'; mediaQuery?: string }> = new Map();
      private originalValues: Map<string, string> = new Map();
      private resizeTimeout: number | null = null;
      
      private getCurrentViewport(): 'small' | 'large' {
        // Use width-based detection (typically 768px breakpoint)
        // --vs is typically max-width, --vl is min-width
        return window.innerWidth < 768 ? 'small' : 'large';
      }

      private readValueFromStylesheet(variableName: string, viewport: 'small' | 'large'): string | null {
        // Try to read the value from CSS rules directly
        // Look for @media (--vs) or @media (--vl) rules that set this variable
        const mediaQuery = viewport === 'small' ? '--vs' : '--vl';
        
        try {
          const stylesheets = Array.from(document.styleSheets);
          for (const stylesheet of stylesheets) {
            try {
              const rules = Array.from(stylesheet.cssRules || []);
              for (const rule of rules) {
                if (rule instanceof CSSMediaRule) {
                  // Check if this media rule matches our target
                  const mediaText = rule.media.mediaText;
                  if (mediaText.includes(mediaQuery)) {
                    // Look for the variable in this media rule
                    const styleRules = Array.from(rule.cssRules || []);
                    for (const styleRule of styleRules) {
                      if (styleRule instanceof CSSStyleRule) {
                        // Check if this rule sets our variable on :root or html
                        if (styleRule.selectorText === ':root' || styleRule.selectorText === 'html') {
                          const value = styleRule.style.getPropertyValue(variableName).trim();
                          if (value) {
                            return value;
                          }
                        }
                      }
                    }
                  }
                } else if (rule instanceof CSSStyleRule) {
                  // Check for :root rules that might have the variable
                  if (rule.selectorText === ':root' || rule.selectorText === 'html') {
                    const value = rule.style.getPropertyValue(variableName).trim();
                    if (value) {
                      // This is a base value, might be overridden by media query
                      // But we'll use it as fallback
                    }
                  }
                }
              }
            } catch (e) {
              // Cross-origin or other issues - skip this stylesheet
              continue;
            }
          }
        } catch (e) {
          // Error reading stylesheets
        }
        
        return null;
      }

      private async readValueForViewport(variableName: string, targetViewport: 'small' | 'large'): Promise<string> {
        // Use the current page URL so the iframe has all the same styles
        return new Promise<string>((resolve) => {
          const iframe = document.createElement('iframe');
          const targetWidth = targetViewport === 'small' ? 767 : 1920;
          
          iframe.style.position = 'fixed';
          iframe.style.width = `${targetWidth}px`;
          iframe.style.height = '100vh';
          iframe.style.left = '-9999px';
          iframe.style.top = '0';
          iframe.style.border = 'none';
          iframe.style.visibility = 'hidden';
          iframe.style.pointerEvents = 'none';
          iframe.style.zIndex = '-9999';
          
          let resolved = false;
          
          const cleanup = () => {
            if (iframe.parentNode) {
              try {
                document.body.removeChild(iframe);
              } catch (e) {
                // Already removed
              }
            }
          };
          
          const readValue = () => {
            try {
              const iframeWindow = iframe.contentWindow;
              const iframeDoc = iframe.contentDocument || iframeWindow?.document;
              
              if (!iframeDoc || !iframeDoc.documentElement) {
                return null;
              }
              
              // Read the value from the iframe's computed styles
              const value = getComputedStyle(iframeDoc.documentElement)
                .getPropertyValue(variableName)
                .trim();
              
              return value || null;
            } catch (error) {
              return null;
            }
          };
          
          iframe.onload = () => {
            // Wait for stylesheets to load and media queries to evaluate
            // Try multiple times with increasing delays
            const attempts = [
              () => setTimeout(() => {
                const value = readValue();
                if (value && value !== '0') {
                  resolved = true;
                  cleanup();
                  resolve(value);
                }
              }, 100),
              () => setTimeout(() => {
                if (!resolved) {
                  const value = readValue();
                  if (value && value !== '0') {
                    resolved = true;
                    cleanup();
                    resolve(value);
                  }
                }
              }, 500),
              () => setTimeout(() => {
                if (!resolved) {
                  const value = readValue();
                  resolved = true;
                  cleanup();
                  resolve(value || '0');
                }
              }, 1000)
            ];
            
            attempts.forEach(attempt => attempt());
          };
          
          iframe.onerror = () => {
            resolved = true;
            cleanup();
            resolve('0');
          };
          
          document.body.appendChild(iframe);
          iframe.src = window.location.href;
          
          // Timeout fallback
          setTimeout(() => {
            if (!resolved) {
              resolved = true;
              const value = readValue();
              cleanup();
              resolve(value || '0');
            }
          }, 3000);
        });
      }

      private getValueForViewport(variableName: string, viewport: 'small' | 'large'): string {
        // Check if there's a saved override first
        const saved = this.getSavedValueRaw(variableName, viewport);
        if (saved !== null) {
          return saved;
        }

        // To read the value from the correct media query, we need to simulate
        // the viewport size. Since we can't directly query custom media queries,
        // we'll use the current value if it matches the current viewport,
        // otherwise we'll need to store the original values per viewport.
        
        // For now, if we're reading for the current viewport, use current value
        const currentViewport = this.getCurrentViewport();
        if (viewport === currentViewport) {
          return this.getCurrentValue(variableName);
        }

        // For the other viewport, we need to read it differently
        // Since CSS variables are evaluated at render time based on media queries,
        // we can't easily read the "other" viewport's value without changing the viewport.
        // Instead, we'll store the original values when first loaded for each viewport.
        
        // Try to get from original values stored per viewport
        const originalKey = `${variableName}-${viewport}`;
        const storedOriginal = this.originalValues.get(originalKey);
        if (storedOriginal) {
          return storedOriginal;
        }

        // Fallback: return current value (will be updated when viewport changes)
        return this.getCurrentValue(variableName);
      }

      private getSavedValueRaw(variableName: string, viewport: 'small' | 'large'): string | null {
        try {
          const storageKey = `${this.storageKey}-${viewport}`;
          const saved = JSON.parse(
            sessionStorage.getItem(storageKey) || '{}'
          );
          const savedValue = saved[variableName];
          if (typeof savedValue === 'number') {
            if (this.isUnitlessVariable(variableName)) {
              return savedValue.toString();
            }
            const currentValue = this.getCurrentValue(variableName);
            const unitMatch = currentValue.match(/[\d.]+(.*)/);
            const unit = unitMatch && unitMatch[1] ? unitMatch[1] : 'px';
            return `${savedValue}${unit}`;
          }
        } catch (error) {
          // Ignore
        }
        return null;
      }

      async init() {
        // Store original values first, before any modifications
        await this.storeOriginalValues();
        // Set up controls
        this.setupVariableControls();
        // Load saved values after controls are set up
        // This will override initial CSS values if saved values exist
        this.loadSavedValues();
        // Update display to show current values
        this.updateDisplayValues();
        // Set up resize listener for viewport-specific variables
        this.setupResizeListener();
      }

      private async storeOriginalValues() {
        // Store original values for each control (including viewport-specific ones)
        const containers = this.$el.querySelectorAll('[data-css-var-container]');
        const currentViewport = this.getCurrentViewport();
        const promises: Promise<void>[] = [];
        
        containers.forEach((container) => {
          const variableName = container.getAttribute('data-css-var-container');
          const viewport = container.getAttribute('data-viewport') as 'small' | 'large' | null;
          if (!variableName) return;
          
          const controlKey = viewport ? `${variableName}-${viewport}` : variableName;
          
          if (viewport) {
            // For viewport-specific variables
            if (viewport === currentViewport) {
              // Current viewport - read directly
              const originalValue = getComputedStyle(document.documentElement)
                .getPropertyValue(variableName)
                .trim();
              this.originalValues.set(controlKey, originalValue || '0');
            } else {
              // Other viewport - try to read from stylesheet first, then fallback to iframe
              let foundValue = false;
              
              // Try to read from stylesheet rules directly
              try {
                const value = this.readValueFromStylesheet(variableName, viewport);
                if (value) {
                  this.originalValues.set(controlKey, value);
                  foundValue = true;
                }
              } catch (e) {
                // Stylesheet reading failed, will use iframe
              }
              
              if (!foundValue) {
                // Set a temporary placeholder first
                this.originalValues.set(controlKey, '0');
                
                // Read using iframe simulation (async)
                const promise = this.readValueForViewport(variableName, viewport).then((value: string) => {
                  if (value && value !== '0') {
                    this.originalValues.set(controlKey, value);
                    // Update controls if they exist
                    const control = this.variableControls.get(controlKey);
                    if (control) {
                      const numericValue = this.parseValue(value);
                      if (numericValue !== null) {
                        control.slider.value = numericValue.toString();
                        control.numberInput.value = numericValue.toString();
                        this.updateDisplayValue(controlKey);
                      }
                    }
                  }
                }).catch(() => {
                  // Keep placeholder if reading fails
                });
                promises.push(promise);
              }
            }
          } else {
            // For non-viewport-specific variables
            const originalValue = getComputedStyle(document.documentElement)
              .getPropertyValue(variableName)
              .trim();
            this.originalValues.set(controlKey, originalValue || '0');
          }
        });
        
        // Wait for all async reads to complete
        await Promise.all(promises);
      }

      private setupVariableControls() {
        // Iterate over containers directly for more reliable setup
        const containers = this.$el.querySelectorAll('[data-css-var-container]');
        containers.forEach((container) => {
          const variableName = container.getAttribute('data-css-var-container');
          const viewport = container.getAttribute('data-viewport') as 'small' | 'large' | null;
          if (!variableName) return;

          // Create unique key for viewport-specific variables
          const controlKey = viewport ? `${variableName}-${viewport}` : variableName;
          
          if (!this.variableControls.has(controlKey)) {
            const mediaQuery = container.getAttribute('data-media-query') || undefined;
            
            // Find all elements within this container
            const slider = container.querySelector(
              viewport
                ? `input[type="range"][data-css-var="${variableName}"][data-viewport="${viewport}"]`
                : `input[type="range"][data-css-var="${variableName}"]:not([data-viewport])`
            ) as HTMLInputElement;
                
            const numberInput = container.querySelector(
              viewport
                ? `input[type="number"][data-css-var="${variableName}"][data-viewport="${viewport}"]`
                : `input[type="number"][data-css-var="${variableName}"]:not([data-viewport])`
            ) as HTMLInputElement;
                
            const valueDisplay = container.querySelector(
              viewport
                ? `[data-css-var-value="${variableName}"][data-viewport="${viewport}"]`
                : `[data-css-var-value="${variableName}"]:not([data-viewport])`
            ) as HTMLElement;
                
            // Find reset icon - check all reset buttons in container and find the one without data-viewport if non-viewport
            let resetIcon: HTMLButtonElement | null = null;
            if (viewport) {
              resetIcon = container.querySelector(
                `button.reset-icon[data-css-var="${variableName}"][data-viewport="${viewport}"]`
              ) as HTMLButtonElement;
            } else {
              // For non-viewport, find button without data-viewport attribute
              const allResetButtons = container.querySelectorAll(`button.reset-icon[data-css-var="${variableName}"]`);
              for (let i = 0; i < allResetButtons.length; i++) {
                const btn = allResetButtons[i] as HTMLButtonElement;
                if (!btn.hasAttribute('data-viewport')) {
                  resetIcon = btn;
                  break;
                }
              }
            }

            if (slider && numberInput && valueDisplay && resetIcon) {
              this.setupVariable(variableName, slider, numberInput, valueDisplay, resetIcon, viewport || undefined, mediaQuery);
            }
          }
        });
      }

      private setupVariable(
        variableName: string,
        slider: HTMLInputElement,
        numberInput: HTMLInputElement,
        valueDisplay: HTMLElement,
        resetIcon: HTMLButtonElement,
        viewport?: 'small' | 'large',
        mediaQuery?: string
      ) {
        const controlKey = viewport ? `${variableName}-${viewport}` : variableName;
        let originalValue = this.originalValues.get(controlKey);
        
        // If no original value stored yet (for async loading), try to get current value
        if (!originalValue || originalValue === '0') {
          if (viewport) {
            const currentViewport = this.getCurrentViewport();
            if (viewport === currentViewport) {
              originalValue = getComputedStyle(document.documentElement)
                .getPropertyValue(variableName)
                .trim() || '0';
              this.originalValues.set(controlKey, originalValue);
            }
          } else {
            originalValue = getComputedStyle(document.documentElement)
              .getPropertyValue(variableName)
              .trim() || '0';
            this.originalValues.set(controlKey, originalValue);
          }
        }

        this.variableControls.set(controlKey, {
          slider,
          numberInput,
          valueDisplay,
          resetIcon,
          viewport,
          mediaQuery,
        });

        const numericValue = this.parseValue(originalValue || '0');
        if (numericValue !== null && numericValue !== 0) {
          slider.value = numericValue.toString();
          numberInput.value = numericValue.toString();
        } else {
          // If value is 0 or invalid, try to read it again after a short delay
          // This handles the case where async reading hasn't completed yet
          setTimeout(() => {
            const updatedValue = this.originalValues.get(controlKey);
            if (updatedValue && updatedValue !== '0') {
              const numVal = this.parseValue(updatedValue);
              if (numVal !== null) {
                slider.value = numVal.toString();
                numberInput.value = numVal.toString();
                this.updateDisplayValue(controlKey);
              }
            }
          }, 500);
        }

        // Bind events
        slider.addEventListener('input', () => {
          this.updateVariable(variableName, slider.value, viewport, mediaQuery);
        });

        numberInput.addEventListener('input', () => {
          this.updateVariable(variableName, numberInput.value, viewport, mediaQuery);
        });

        slider.addEventListener('input', () => {
          numberInput.value = slider.value;
        });

        numberInput.addEventListener('input', () => {
          const numValue = parseFloat(numberInput.value);
          if (!isNaN(numValue)) {
            slider.value = numValue.toString();
          }
        });

        resetIcon.addEventListener('click', () => {
          this.resetVariable(variableName, viewport);
        });
      }

      private getCurrentValue(variableName: string): string {
        // For viewport-specific variables, extract the base name
        const baseName = variableName.replace(/-small$|-large$/, '');
        const value = getComputedStyle(document.documentElement)
          .getPropertyValue(baseName)
          .trim();
        return value || '0';
      }

      private parseValue(value: string): number | null {
        // Extract numeric value from CSS value (e.g., "100px" -> 100, "1.5rem" -> 1.5)
        const match = value.match(/^([\d.]+)/);
        return match ? parseFloat(match[1]) : null;
      }

      private isUnitlessVariable(variableName: string): boolean {
        // List of variables that don't have units (e.g., aspect ratios, ratios, etc.)
        const unitlessVariables = [
          '--fluid-aspect-ratio-max',
          '--fluid-aspect-ratio-min',
        ];
        return unitlessVariables.includes(variableName);
      }

      private updateVariable(variableName: string, value: string, viewport?: 'small' | 'large', mediaQuery?: string, save: boolean = true) {
        const numValue = parseFloat(value);
        if (isNaN(numValue)) return;

        const controlKey = viewport ? `${variableName}-${viewport}` : variableName;
        const control = this.variableControls.get(controlKey);
        if (!control) return;

        // Determine unit from original value, default to px (unless unitless)
        let newValue: string;
        if (this.isUnitlessVariable(variableName)) {
          newValue = numValue.toString();
        } else {
          const originalValue = this.originalValues.get(controlKey) || this.getCurrentValue(variableName);
          const unitMatch = originalValue.match(/[\d.]+(.*)/);
          const unit = unitMatch && unitMatch[1] ? unitMatch[1] : 'px';
          newValue = `${numValue}${unit}`;
        }
        
        // Only apply if this is for the current viewport or if no viewport specified
        if (viewport) {
          const currentViewport = this.getCurrentViewport();
          if (viewport === currentViewport) {
            // Apply inline style only when the corresponding media query is active
            document.documentElement.style.setProperty(variableName, newValue);
          }
          // Always save the value for this viewport
          if (save) {
            this.saveValue(controlKey, numValue);
          }
        } else {
          // Non-viewport-specific variable
          document.documentElement.style.setProperty(variableName, newValue);
          if (save) {
            this.saveValue(variableName, numValue);
          }
        }
        
        this.updateDisplayValue(controlKey);
        this.updateModifiedState(controlKey);
      }


      private updateDisplayValue(controlKey: string) {
        const control = this.variableControls.get(controlKey);
        if (!control) return;

        const variableName = control.viewport 
          ? controlKey.replace(`-${control.viewport}`, '')
          : controlKey;
        const isUnitless = this.isUnitlessVariable(variableName);

        // Helper to strip units for unitless variables
        const formatValue = (value: string): string => {
          if (isUnitless) {
            // Strip any units for unitless variables
            const match = value.match(/^([\d.]+)/);
            return match ? match[1] : value;
          }
          return value;
        };

        // For viewport-specific variables, show the value only when that viewport is active
        if (control.viewport) {
          const currentViewport = this.getCurrentViewport();
          if (control.viewport === currentViewport) {
            const currentValue = this.getCurrentValue(variableName);
            control.valueDisplay.textContent = formatValue(currentValue);
          } else {
            // Show saved value or original value for inactive viewport
            const original = this.originalValues.get(controlKey);
            control.valueDisplay.textContent = formatValue(original || '0');
          }
        } else {
          const currentValue = this.getCurrentValue(variableName);
          control.valueDisplay.textContent = formatValue(currentValue);
        }
      }

      private updateDisplayValues() {
        this.variableControls.forEach((_, controlKey) => {
          this.updateDisplayValue(controlKey);
          this.updateModifiedState(controlKey);
        });
      }

      private setupResizeListener() {
        // Use a debounced resize listener to update viewport-specific variables
        window.addEventListener('resize', () => {
          if (this.resizeTimeout) {
            clearTimeout(this.resizeTimeout);
          }
          
          this.resizeTimeout = window.setTimeout(() => {
            const currentViewport = this.getCurrentViewport();
            
            // Update all viewport-specific controls
            this.variableControls.forEach((control, controlKey) => {
              if (control.viewport) {
                const variableName = controlKey.replace(`-${control.viewport}`, '');
                
                // Store original value for current viewport
                if (control.viewport === currentViewport) {
                  const currentValue = getComputedStyle(document.documentElement)
                    .getPropertyValue(variableName)
                    .trim();
                  this.originalValues.set(controlKey, currentValue || '0');
                  
                  // Update controls with current value
                  const numericValue = this.parseValue(currentValue);
                  if (numericValue !== null) {
                    control.slider.value = numericValue.toString();
                    control.numberInput.value = numericValue.toString();
                  }
                  
                  // Check if there's a saved override
                  try {
                    const saved = JSON.parse(
                      sessionStorage.getItem(this.storageKey) || '{}'
                    );
                    
                    if (typeof saved[controlKey] === 'number') {
                      // Apply saved override
                      if (this.isUnitlessVariable(variableName)) {
                        document.documentElement.style.setProperty(
                          variableName,
                          saved[controlKey].toString()
                        );
                      } else {
                        const unitMatch = currentValue.match(/[\d.]+(.*)/);
                        const unit = unitMatch && unitMatch[1] ? unitMatch[1] : 'px';
                        document.documentElement.style.setProperty(
                          variableName,
                          `${saved[controlKey]}${unit}`
                        );
                      }
                    } else {
                      // Remove inline style to use CSS value
                      document.documentElement.style.removeProperty(variableName);
                    }
                  } catch (error) {
                    // Ignore
                  }
                } else {
                  // For inactive viewport, try to read its value using iframe
                  this.readValueForViewport(variableName, control.viewport).then((value: string) => {
                    this.originalValues.set(controlKey, value || '0');
                    const numericValue = this.parseValue(value);
                    if (numericValue !== null) {
                      control.slider.value = numericValue.toString();
                      control.numberInput.value = numericValue.toString();
                    }
                    this.updateDisplayValue(controlKey);
                  }).catch(() => {
                    // Keep existing value if reading fails
                  });
                }
                
                // Update display and controls
                this.updateDisplayValue(controlKey);
                this.updateModifiedState(controlKey);
              }
            });
          }, 150);
        });
      }

      private updateModifiedState(controlKey: string) {
        const control = this.variableControls.get(controlKey);
        if (!control) return;

        // Find the container for this control
        const variableName = control.viewport 
          ? controlKey.replace(`-${control.viewport}`, '')
          : controlKey;
        
        // Build selector based on whether it's viewport-specific or not
        let container: HTMLElement | null = null;
        if (control.viewport) {
          container = this.$el.querySelector(
            `[data-css-var-container="${variableName}"][data-viewport="${control.viewport}"]`
          ) as HTMLElement;
        } else {
          // For non-viewport variables, find container without data-viewport attribute
          const containers = this.$el.querySelectorAll(`[data-css-var-container="${variableName}"]`);
          for (let i = 0; i < containers.length; i++) {
            const cont = containers[i] as HTMLElement;
            if (!cont.hasAttribute('data-viewport')) {
              container = cont;
              break;
            }
          }
        }
        
        if (!container) return;

        let isModified = false;

        // Check if there's a saved override
        try {
          const saved = JSON.parse(
            sessionStorage.getItem(this.storageKey) || '{}'
          );
          isModified = typeof saved[controlKey] === 'number';
        } catch (error) {
          isModified = false;
        }

        // For viewport-specific variables, also check inline style if current viewport
        if (control.viewport) {
          const currentViewport = this.getCurrentViewport();
          if (control.viewport === currentViewport) {
            const inlineStyle = document.documentElement.style.getPropertyValue(variableName);
            if (inlineStyle && inlineStyle.trim() !== '') {
              isModified = true;
            }
          }
        } else {
          // For non-viewport-specific, check inline style first
          const inlineStyle = document.documentElement.style.getPropertyValue(variableName);
          if (inlineStyle && inlineStyle.trim() !== '') {
            isModified = true;
          } else {
            // If no inline style, compare computed value with original
            const originalValue = this.originalValues.get(controlKey) || '0';
            const currentValue = this.getCurrentValue(variableName);
            
            // Normalize values for comparison (strip units for unitless variables)
            const isUnitless = this.isUnitlessVariable(variableName);
            let normalizedOriginal = originalValue.trim() || '0';
            let normalizedCurrent = currentValue.trim() || '0';
            
            if (isUnitless) {
              // Strip units from both values for comparison
              const originalMatch = normalizedOriginal.match(/^([\d.]+)/);
              const currentMatch = normalizedCurrent.match(/^([\d.]+)/);
              normalizedOriginal = originalMatch ? originalMatch[1] : normalizedOriginal;
              normalizedCurrent = currentMatch ? currentMatch[1] : normalizedCurrent;
            }
            
            isModified = normalizedOriginal !== normalizedCurrent || isModified;
          }
        }
        
        // Also check if there's a saved value (this check is redundant but kept for safety)
        if (!isModified) {
          try {
            const saved = JSON.parse(
              sessionStorage.getItem(this.storageKey) || '{}'
            );
            isModified = typeof saved[controlKey] === 'number';
          } catch {
            // Ignore
          }
        }
        
        container.classList.toggle('-modified', isModified);
        control.resetIcon.style.visibility = isModified ? 'visible' : 'hidden';
        control.resetIcon.style.pointerEvents = isModified ? 'auto' : 'none';
      }

      private saveValue(variableName: string, value: number) {
        try {
          const saved = JSON.parse(
            sessionStorage.getItem(this.storageKey) || '{}'
          );
          saved[variableName] = value;
          sessionStorage.setItem(this.storageKey, JSON.stringify(saved));
        } catch (error) {
          console.warn('Unable to save CSS variable value', error);
        }
      }

      private loadSavedValues() {
        try {
          const saved = JSON.parse(
            sessionStorage.getItem(this.storageKey) || '{}'
          );

          this.variableControls.forEach((control, controlKey) => {
            const savedValue = saved[controlKey];
            if (typeof savedValue === 'number') {
              control.slider.value = savedValue.toString();
              control.numberInput.value = savedValue.toString();
              
              // Extract variable name and viewport from controlKey
              const parts = controlKey.split('-');
              const viewport = control.viewport;
              const variableName = viewport 
                ? controlKey.replace(`-${viewport}`, '')
                : controlKey;
              
              this.updateVariable(
                variableName, 
                savedValue.toString(), 
                viewport, 
                control.mediaQuery, 
                false
              );
            } else {
              this.updateModifiedState(controlKey);
            }
          });
        } catch (error) {
          console.warn('Unable to load saved CSS variable values', error);
        }
      }

      private resetVariable(variableName: string, viewport?: 'small' | 'large') {
        const controlKey = viewport ? `${variableName}-${viewport}` : variableName;
        const control = this.variableControls.get(controlKey);
        if (!control) return;

        // Remove from sessionStorage first
        try {
          const saved = JSON.parse(
            sessionStorage.getItem(this.storageKey) || '{}'
          );
          delete saved[controlKey];
          sessionStorage.setItem(this.storageKey, JSON.stringify(saved));
        } catch (error) {
          console.warn('Unable to remove CSS variable value from storage', error);
        }

        // Remove the inline style only if this is the current viewport
        if (viewport) {
          const currentViewport = this.getCurrentViewport();
          if (viewport === currentViewport) {
            document.documentElement.style.removeProperty(variableName);
          }
        } else {
          document.documentElement.style.removeProperty(variableName);
        }

        // Get original value
        const originalValue = this.originalValues.get(controlKey) || '0';
        const numericValue = this.parseValue(originalValue);
        
        if (numericValue !== null) {
          control.slider.value = numericValue.toString();
          control.numberInput.value = numericValue.toString();
        }

        // Update display and modified state
        setTimeout(() => {
          this.updateDisplayValue(controlKey);
          this.updateModifiedState(controlKey);
        }, 0);
      }
    },
  );
</script>

<style lang="scss">
  .debug-css-variables {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-top: 8px;
    padding-top: 8px;

    > .viewport-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px;
      border: 1px solid var(--debug-view-color-lines, #e3e1e1);
      border-radius: 6px;
      background: rgba(0, 0, 0, 0.02);

      > .viewport-group-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 4px;
        padding-bottom: 8px;
        border-bottom: 1px solid var(--debug-view-color-lines, #e3e1e1);

        > .viewport-group-title {
          font-size: 12px;
          font-weight: 700;
          color: var(--debug-view-foreground-color, black);
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }

        > .viewport-group-badge {
          font-size: 9px;
          font-weight: 600;
          font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
          color: rgba(0, 0, 0, 0.5);
          background: rgba(0, 0, 0, 0.05);
          padding: 2px 6px;
          border-radius: 3px;
        }
      }

      > .viewport-group-controls {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
    }

    > .variable-control,
    .viewport-group-controls > .variable-control {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 8px;
      border-radius: 4px;
      transition: background-color 0.2s ease;

      &.-modified {
        background-color: rgba(255, 200, 200, 0.3);
      }
    }

    .variable-control {
      > .label {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 11px;
        color: var(--debug-view-foreground-color, black);
        gap: 8px;

        > .label-text {
          font-weight: 600;
          font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;

          > .responsive-badge,
          > .viewport-badge {
            display: inline-block;
            margin-left: 6px;
            padding: 2px 6px;
            font-size: 8px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: rgba(0, 0, 0, 0.5);
            background: rgba(0, 0, 0, 0.05);
            border-radius: 3px;
            vertical-align: middle;
          }
        }

        > .value-wrapper {
          display: flex;
          align-items: center;
          gap: 6px;

          > .reset-icon {
            visibility: hidden;
            pointer-events: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            padding: 0;
            border: none;
            background: transparent;
            color: rgba(0, 0, 0, 0.5);
            cursor: pointer;
            transition:
              visibility 0.15s ease,
              color 0.15s ease,
              transform 0.15s ease;
            flex-shrink: 0;

            > svg {
              width: 100%;
              height: 100%;
            }

            &:hover {
              color: var(--debug-view-accent-color, rgba(40, 30, 213, 1));
              transform: rotate(180deg);
            }

            &:active {
              transform: rotate(180deg) scale(0.9);
            }

            &:focus {
              outline: none;
              color: var(--debug-view-accent-color, rgba(40, 30, 213, 1));
            }
          }

          > .value {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            color: rgba(0, 0, 0, 0.7);
            font-weight: 500;
          }
        }
      }

      > .input-group {
        display: flex;
        align-items: center;
        gap: 8px;

        > .slider {
          flex: 1;
          height: 6px;
          border-radius: 3px;
          background: var(--debug-view-color-lines, #e3e1e1);
          outline: none;
          -webkit-appearance: none;
          appearance: none;

          &::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--debug-view-accent-color, rgba(40, 30, 213, 1));
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: transform 0.15s ease;

            &:hover {
              transform: scale(1.1);
            }
          }

          &::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--debug-view-accent-color, rgba(40, 30, 213, 1));
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: transform 0.15s ease;

            &:hover {
              transform: scale(1.1);
            }
          }
        }

        > .number-input {
          width: 60px;
          padding: 6px 8px;
          border: 1px solid var(--debug-view-color-lines, #e3e1e1);
          border-radius: 4px;
          font-size: 11px;
          font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
          background: white;
          color: var(--debug-view-foreground-color, black);
          transition:
            border-color 0.15s ease,
            box-shadow 0.15s ease;

          &:focus {
            outline: none;
            border-color: var(--debug-view-accent-color, rgba(40, 30, 213, 1));
            box-shadow: 0 0 0 2px rgba(40, 30, 213, 0.1);
          }
        }

      }
    }
  }
</style>
